<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<!--Json là 1 định dạng dữ liệu (chuỗi). Có thể viết bất cứ đâu. Nếu viết đúng cú pháp thì nó là Json
        Json (JavaScript Object Notation) 
        Json: Number, Boolean, Null, Array, Object 
    -->
<!-- 
    + Stringify: từ Javascript -> Json
    + Parse: từ Json -> JavaScript
    -->

<!-- Promise
    + Là một đối tượng dùng để xử lý các tác vụ bất đồng bộ 
    Trước khi có Promise, các tác vụ bất đồng bộ thường được xử lý bằng callback functions. 
    Tuy nhiên, khi có nhiều tác vụ bất đồng bộ lồng vào nhau, 
    code sẽ trở nên rất khó đọc và khó quản lý, dẫn đến tình trạng gọi là "Callback Hell" 

    + Cách tạo: 
    - resolve: Hàm này được gọi khi tác vụ bất đồng bộ hoàn tất thành công, và value là giá trị trả về.
    - reject: Hàm này được gọi khi tác vụ bất đồng bộ thất bại, và error là đối tượng lỗi.

    + Cách gọi khác: 
    - .then(): Được sử dụng để xử lý kết quả khi Promise thành công (Fulfilled). 
    Nó có thể nhận hai hàm callback: một cho trường hợp thành công và một cho trường hợp thất bại (tùy chọn).
    - .catch(): Là một cách viết gọn của .then(null, rejectionHandler). 
    Nó được sử dụng để xử lý lỗi khi Promise thất bại (Rejected).
    - .finally(): Được gọi khi Promise đã hoàn tất, bất kể nó thành công hay thất bại. 
    - Promise.all(): Chờ đợi tất cả các Promise trong một mảng được giải quyết (hoặc một trong số chúng thất bại).
    - Promise.race(): Trả về Promise đầu tiên được giải quyết (thành công hoặc thất bại) từ một tập hợp các Promise.
    - Promise.resolve(): Trả về một Promise đã Fulfilled với một giá trị cho trước.
    - Promise.reject(): Trả về một Promise đã Rejected với một lý do cho trước.

    + Lưu ý: 
    - VD có promise thứ 1 và có 2 .then và nếu .then thứ 2 tạo 1 promise thứ 2 thì từ .then thú 3 sẽ theo promise thứ 2
    => Đó gọi là Promise Chaining 
-->


<!-- Arrow function
    + Hàm không tham số 
    let sayHello = () => "Hello!";
    console.log(sayHello()); // Output: Hello!

    + Hàm một tham số 
    let square = n => n * n; // Có thể bỏ dấu ngoặc đơn cho tham số
    console.log(square(5)); // Output: 25

    + Hàm nhiều tham số
    let sum = (a, b) => a + b;
    console.log(sum(3, 7)); // Output: 10

    + Hàm với nhiều dòng code
    let calculateTax = (price, taxRate) => {
    let taxAmount = price * taxRate;
    return price + taxAmount;
    };
    console.log(calculateTax(100, 0.1)); // Output: 110
-->

<!-- Template String
    Sử dụng dấu backtick (`) và dấu ${tên biến} để in ra tên biến 
    const messageBackticks = `Xin chào, ${name}!`;
    console.log(messageBackticks); // Output: Xin chào, Lan!
-->

<!-- 
    Default parameter values là nó gán giá trị mặc định cho hàm đó 
    function sayHello(name = "Guest") { // 'name' có giá trị mặc định là "Guest"
    console.log(`Hello, ${name}!`);

    sayHello();          // Output: Hello, Guest! 
    sayHello("Alice");   // Output: Hello, Alice! 
    sayHello(undefined); // Output: Hello, Guest! 
    sayHello(null);      // Output: Hello, null! 
}   
-->

<!-- 
    Destructuring cho phép bạn "mở gói" các giá trị từ mảng hoặc các thuộc tính từ đối tượng vào các biến riêng biệt. 
    Nó cung cấp một cách ngắn gọn và dễ đọc hơn để trích xuất dữ liệu.

    const numbers = [1, 2, 3, 4, 5];

    // Phân rã cơ bản
    const [first, second] = numbers;
    console.log(first);  // Kết quả: 1
    console.log(second); // Kết quả: 2

    // Bỏ qua các phần tử
    const [,, third, fourth] = numbers;
    console.log(third);  // Kết quả: 3
    console.log(fourth); // Kết quả: 4

    // Gán các phần tử còn lại vào một mảng mới (sử dụng rest parameter ở đây, xem phần dưới)
    const [a, b, ...restOfNumbers] = numbers;
    console.log(a);               // Kết quả: 1
    console.log(b);               // Kết quả: 2
    console.log(restOfNumbers);   // Kết quả: [3, 4, 5]

    // Giá trị mặc định
    const [x, y, z = 10] = [1, 2];
    console.log(x); // Kết quả: 1
    console.log(y); // Kết quả: 2
    console.log(z); // Kết quả: 10 (vì z không có trong mảng ban đầu)

    // Đổi chỗ các biến (một trường hợp sử dụng kinh điển)
    let var1 = 'hello';
    let var2 = 'world';
    [var1, var2] = [var2, var1];
    console.log(var1); // Kết quả: world
    console.log(var2); // Kết quả: hello
-->

<!-- 
    Rest parameter cho phép một hàm chấp nhận một số lượng đối số không xác định dưới dạng một mảng. 
    Nó tập hợp các đối số còn lại vào một mảng duy nhất

    // Ví dụ 1: Tổng của một số lượng số không xác định
    function sum(...numbers) {
    let total = 0;
    for (const num of numbers) {
        total += num;
    }
    return total;
    }

    console.log(sum(1, 2));         // Kết quả: 3
    console.log(sum(1, 2, 3, 4, 5)); // Kết quả: 15
    console.log(sum());             // Kết quả: 0

    // Ví dụ 2: Rest parameter trong phân rã mảng (như đã thấy ở trên)
    const [first, ...remaining] = [10, 20, 30, 40];
    console.log(first);    // Kết quả: 10
    console.log(remaining); // Kết quả: [20, 30, 40]
-->

<!-- 
    Spread syntax cho phép bạn mở rộng một iterable (như một mảng, một chuỗi, hoặc một đối tượng) 
    thành các phần tử riêng lẻ. Nói một cách dễ hiểu hơn, nó giống như việc "rải" các phần tử của một tập hợp ra.

    // Sử dụng với mảng 
    const arr1 = [1, 2, 3];
    const arr2 = [4, 5, 6];
    // Kết hợp hai mảng
    const combinedArray = [...arr1, ...arr2];
    console.log(combinedArray); // Kết quả: [1, 2, 3, 4, 5, 6]
    // Thay vì dùng arr1.concat(arr2)
    // Tạo một bản sao nông (shallow copy) của mảng
    const originalArray = [10, 20, 30];
    const copiedArray = [...originalArray];
    console.log(copiedArray); // Kết quả: [10, 20, 30]
    // Thay vì dùng originalArray.slice()
    // Thêm phần tử vào một mảng mới mà không làm thay đổi mảng gốc
    const fruits = ['apple', 'banana'];
    const newFruits = ['grape', ...fruits, 'orange'];
    console.log(newFruits); // Kết quả: ['grape', 'apple', 'banana', 'orange']


    // Sử dụng với object 
    const user = {
    name: 'Alice',
    age: 30
    };
    const address = {
    city: 'New York',
    zip: '10001'
    };
    // Kết hợp hai đối tượng
    const userWithAddress = { ...user, ...address };
    console.log(userWithAddress);
    // Kết quả: { name: 'Alice', age: 30, city: 'New York', zip: '10001' }
    // Tạo một bản sao nông của đối tượng
    const originalUser = { id: 1, name: 'Bob' };
    const copiedUser = { ...originalUser };
    console.log(copiedUser); // Kết quả: { id: 1, name: 'Bob' }
    // Ghi đè thuộc tính
    const profile = { name: 'Charlie', age: 25 };
    const updatedProfile = { ...profile, age: 26, city: 'London' };
    console.log(updatedProfile);
    // Kết quả: { name: 'Charlie', age: 26, city: 'London' }
    // Lưu ý: age đã bị ghi đè bởi giá trị mới


    // Sử dụng với hàm 
    function sum(a, b, c) {
    return a + b + c;
    }
    const numbers = [1, 2, 3];
    console.log(sum(...numbers)); // Kết quả: 6
    // Tương đương với sum(numbers[0], numbers[1], numbers[2]) hoặc sum(1, 2, 3)
    const maxNumber = Math.max(...[10, 5, 20, 15]);
    console.log(maxNumber); // Kết quả: 20

    // Sử dụng với chuỗi 
    const greeting = "hello";
    const chars = [...greeting];
    console.log(chars); // Kết quả: ['h', 'e', 'l', 'l', 'o']
-->


<!-- 
    Module (hay còn gọi là mô-đun) 
    là một cách để bạn tổ chức code của mình thành các đơn vị độc lập, có thể tái sử dụng (import / export)

    + Export
    - Từng phần tử: 
    export const PI = 3.14;

    export function add(a, b) {
    return a + b;
    }

    export class Calculator {
    // ...
    }

    - Mặc định: Mỗi module chỉ có thể có một export default. Đây là cách để xuất "thứ chính" mà module đó cung cấp.
    function logMessage(message) {
    console.log(`[LOG]: ${message}`);
    }
    export default logMessage; // Xuất hàm này làm giá trị mặc định
    
    + Import 
    - Mặc định: Import mặc định (Default Import): Khi import một export default, bạn có thể đặt bất kỳ tên nào cho nó.
    
    import myLogger from './logger.js'; // 'myLogger' là tên bạn đặt cho logMessage
    myLogger('Hello from module!');

    - Import tất cả: 
    import * as MathUtils from './math.js';   // Nếu import tất cả thì bắt buộc phải đặt tên còn riêng rẻ như ở dưới thì không 
    hoặc 
    import {PI,add} from './math.js'

    console.log(MathUtils.PI);
    console.log(MathUtils.add(5, 7));

    + Lưu ý: 
    - Mỗi 1 file chỉ đặt default 1 lần 
    - Khi export đặt 1 hàm hay cái gì đó mặc định (có default phía trước) thì bên import 
    khi gọi sẽ không cần theo tên bên import có thể đặt tên khác (Ví dụ ở trên)
    - Khi không có default thì khi sử dụng bên import phải gọi đúng tên hàm 
-->

<!-- 
    Optional Chaining (?.) là một cú pháp mới trong JavaScript 
    cho phép bạn đọc giá trị của một thuộc tính sâu bên trong một chuỗi các đối tượng lồng nhau mà 
    không cần phải kiểm tra rõ ràng từng cấp độ xem nó có tồn tại hay không  

    + Cách cũ
    const user = {
    name: 'Alice',
    address: {
        city: 'Hanoi',
        detail: {
        street: 'Nguyen Hue',
        zip: '10000'
        }
    }
    };

    // Trường hợp 1: Tất cả đều tồn tại
    let streetName;
    if (user && user.address && user.address.detail) {
    streetName = user.address.detail.street;
    }
    console.log(streetName); // Output: Nguyen Hue

    // Trường hợp 2: address không tồn tại
    const user2 = {
    name: 'Bob'
    };

    let streetName2;
    if (user2 && user2.address && user2.address.detail) { // user2.address là undefined, điều kiện sai
    streetName2 = user2.address.detail.street;
    }
    console.log(streetName2); // Output: undefined (không lỗi, nhưng rất dài dòng)

    // Nếu không kiểm tra, sẽ lỗi:
    // console.log(user2.address.detail.street); // Lỗi: TypeError: Cannot read properties of undefined (reading 'detail')

    + Cách mới
    const user = {
    name: 'Alice',
    address: {
        city: 'Hanoi',
        detail: {
        street: 'Nguyen Hue',
        zip: '10000'
        }
    }
    };

    const streetName = user?.address?.detail?.street;
    console.log(streetName); // Output: Nguyen Hue

    const user2 = {
    name: 'Bob'
    };

    const streetName2 = user2?.address?.detail?.street;
    console.log(streetName2); // Output: undefined (không gây lỗi)

    const user3 = {
    name: 'Charlie',
    address: null // address là null
    };

    const streetName3 = user3?.address?.detail?.street;
    console.log(streetName3); // Output: undefined (không gây lỗi)
-->

<body>

</body>

</html>